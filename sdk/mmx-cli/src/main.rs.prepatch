
// 0BSD â€” zero attribution
use anyhow::{Context, Result};
use clap::{Parser, Subcommand, Args};
use mmx_core::{
    HlsVariant, AudioVariant, Packager, codecs_tag, derive_bandwidth,
    write_hls_master, write_hls_variant_playlist, write_audio_playlist, write_dash_mpd,
};

#[derive(Parser)]
#[command(name="mmx", version, about="Modern Multimedia eXchange (manifest prototype)")]
struct Cli {
    #[arg(long, default_value="info")]
    log: String,
    #[command(subcommand)]
    cmd: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Build ABR packaging (HLS TS / HLS CMAF / DASH CMAF) from rung definitions
    Pack(PackArgs),

    /// Quick ladder expansion and validation report
    Ladder(LadderArgs),
}

#[derive(Args)]
struct PackArgs {
    /// Output root directory (playlists will be written under here)
    #[arg(long, default_value="out")]
    out_dir: String,

    /// Packager: hls-ts | hls-cmaf | dash-cmaf
    #[arg(long, default_value="hls-ts")]
    packager: String,

    /// Single-flag ladder: 1080p:5M,720p:3M,480p:1.6M
    #[arg(long)]
    ladder: Option<String>,

    /// JSON array of HlsVariant structures (overrides ladder rungs)
    #[arg(long)]
    hls_variants_json: Option<String>,

    /// JSON array of AudioVariant structures
    #[arg(long)]
    audio_variants_json: Option<String>,
}

#[derive(Args)]
struct LadderArgs {
    #[arg(long)]
    ladder: String,
}

fn parse_ladder(s: &str) -> Result<Vec<(String,(u32,u32),u32)>> {
    fn res(label:&str)->Option<(u32,u32)> {
        match label {
            "2160p" => Some((3840,2160)),
            "1440p" => Some((2560,1440)),
            "1080p" => Some((1920,1080)),
            "720p"  => Some((1280,720)),
            "540p"  => Some((960,540)),
            "480p"  => Some((854,480)),
            "360p"  => Some((640,360)),
            _ => None
        }
    }
    fn bw(v:&str)->Option<u32>{
        let u=v.to_uppercase();
        if u.ends_with('M'){ u[..u.len()-1].parse::<f32>().ok().map(|m| (m*1_000_000.0) as u32) }
        else if u.ends_with('K'){ u[..u.len()-1].parse::<f32>().ok().map(|k| (k*1_000.0) as u32) }
        else { v.parse::<u32>().ok() }
    }
    let mut out=vec![];
    for term in s.split(',') {
        let (label,b)=term.split_once(':').context("use label:bitrate")?;
        let r = res(label).context("unknown rung label")?;
        let bb = bw(b).context("bad bitrate")?;
        out.push((label.to_string(), r, bb));
    }
    Ok(out)
}

fn ladder_to_variants(ladder:&str)->Result<Vec<HlsVariant>>{
    let rows = parse_ladder(ladder)?;
    Ok(rows.into_iter().map(|(name,res,_bw)| HlsVariant{
        name,
        bandwidth: 0, // auto
        res: Some(res),
        dir: format!("out/{}p", res.1),
        codecs: None,
        vcodec: None, acodec: None,
        vbv_maxrate: None, vbv_bufsize: None, gop: None, profile: None,
        encoder_family: None, abitrate: None, cmaf: None,
    }).collect())
}

fn parse_packager(s:&str)->Packager{
    match s {
        "hls-ts" => Packager::HlsTs,
        "hls-cmaf" => Packager::HlsCmaf,
        "dash-cmaf" => Packager::DashCmaf,
        _ => Packager::HlsTs
    }
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Pack(a) => cmd_pack(a),
        Command::Ladder(a) => cmd_ladder(a),
    }
}

fn cmd_ladder(a: LadderArgs) -> Result<()> {
    let vars = ladder_to_variants(&a.ladder)?;
    println!("Expanded ladder:");
    for v in vars {
        println!("  {}  dir={}  res={:?}", v.name, v.dir, v.res);
    }
    Ok(())
}

fn cmd_pack(a: PackArgs) -> Result<()> {
    let mut variants: Vec<HlsVariant> = if let Some(j) = a.hls_variants_json.as_ref() {
        serde_json::from_str(j).context("--hls-variants-json bad JSON")?
    } else if let Some(l) = a.ladder.as_ref() {
        ladder_to_variants(l)?
    } else {
        ladder_to_variants("720p:3M,480p:1.6M")?
    };

    let audios: Vec<AudioVariant> = if let Some(j) = a.audio_variants_json.as_ref() {
        serde_json::from_str(j).context("--audio-variants-json bad JSON")?
    } else { vec![] };

    let mut built_video: Vec<(String,u32,Option<(u32,u32)>,String,String,Option<String>,bool)> = vec![];
    for v in &mut variants {
        let vcodec = v.vcodec.clone().unwrap_or_else(|| "h264".into());
        let acodec = v.acodec.clone().unwrap_or_else(|| "aac".into());
        let abitrate = v.abitrate.unwrap_or(128_000);
        if v.bandwidth == 0 {
            let enc_bitrate = v.vbv_maxrate;
            v.bandwidth = derive_bandwidth(v.vbv_maxrate, enc_bitrate, Some(abitrate), v.res);
        }
        let codecs = v.codecs.clone().unwrap_or_else(|| codecs_tag(&vcodec, &acodec, v.profile.as_deref()));
        built_video.push((
            v.name.clone(),
            v.bandwidth,
            v.res,
            v.dir.clone(),
            codecs,
            None::<String>,
            v.cmaf.unwrap_or(false),
        ));
    }

    let mut built_audio: Vec<(String,String,String,bool,String,String)> = vec![];
    if !audios.is_empty() {
        let group = audios.first().map(|a| a.group.clone()).unwrap_or_else(|| "aud_stereo".into());
        for b in &mut built_video { b.5 = Some(group.clone()); }
        for adef in &audios {
            let dir = std::path::Path::new(&adef.dir);
            write_audio_playlist(dir, &adef.name)?;
            built_audio.push((adef.group.clone(), adef.name.clone(), adef.lang.clone(), adef.default, adef.dir.clone(), format!("{}.m3u8", adef.name)));
        }
    }

    let out_root = std::path::Path::new(&a.out_dir);
    match parse_packager(&a.packager) {
        Packager::HlsTs => {
            for (name, _bw, _res, dir, _codecs, _ag, _cmaf) in &built_video {
                let vdir = out_root.join(dir);
                write_hls_variant_playlist(&vdir, name, false)?;
            }
            let master_path = out_root.join("master.m3u8");
            let shaped: Vec<_> = built_video.iter().map(|b| (b.0.clone(), b.1, b.2, b.3.clone(), b.4.clone(), b.5.clone())).collect();
            write_hls_master(&master_path, &shaped, &built_audio)?;
        }
        Packager::HlsCmaf => {
            for (name, _bw, _res, dir, _codecs, _ag, _cmaf) in &built_video {
                let vdir = out_root.join(dir);
                write_hls_variant_playlist(&vdir, name, true)?;
            }
            let master_path = out_root.join("master.m3u8");
            let shaped: Vec<_> = built_video.iter().map(|b| (b.0.clone(), b.1, b.2, b.3.clone(), b.4.clone(), b.5.clone())).collect();
            write_hls_master(&master_path, &shaped, &built_audio)?;
        }
        Packager::DashCmaf => {
            let v_reps: Vec<_> = built_video.iter().map(|b| (b.0.clone(), b.1, b.2, b.3.clone(), b.4.clone())).collect();
            for (_n,_bw,_r,dir,_c) in &v_reps { std::fs::create_dir_all(out_root.join(dir))?; }
            let a_rep = built_audio.first().map(|(_g,n,_lang,_def,dir,_file)| (n.clone(), 128_000u32, dir.clone()));
            let mpd = out_root.join("manifest.mpd");
            write_dash_mpd(&mpd, &v_reps, a_rep)?;
        }
    }

    println!("ABR validation report:");
    println!("  Packager: {}", a.packager);
    for (name, bw, res, dir, codecs, ag, cmaf) in &built_video {
        let res_s = res.map(|(w,h)| format!("{}x{}", w,h)).unwrap_or_else(|| "-".into());
        let ags = ag.clone().unwrap_or_else(|| "-".into());
        println!("  - {name:<8} bw={bw} res={res_s:<10} dir={dir:<20} codecs={codecs} audio_group={ags} cmaf={cmaf}");
    }
    if !built_audio.is_empty() {
        println!("  Audio groups:");
        for (g,n,lang,def,dir,file) in &built_audio {
            println!("  - group={g} name={n} lang={lang} default={} uri={}/{}", if *def {"YES"} else {"NO"}, dir, file);
        }
    }
    println!("Outputs written under: {}", out_root.display());
    Ok(())
}
