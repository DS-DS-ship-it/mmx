use std::process::Command as Proc;
use anyhow::{bail, Result};
use mmx_core::backend::{self, QcOptions, RunOptions};
use mmx_core::probe_ffprobe_fallback;
use mmx_core::packager::{self, PackKind};
use clap::{Args, Parser, Subcommand};

//
// ---------- which_path() (unified + safe)
//
fn which_path(bin: &str) -> Option<String> {
    // Environment variable override: FFMPEG / FFPROBE / GST-LAUNCH-1.0
    let env_key = bin.to_uppercase().replace('-', "_").replace('.', "_");
    if let Ok(p) = std::env::var(&env_key) {
        let p = p.trim();
        if !p.is_empty() && std::path::Path::new(p).is_file() {
            return Some(p.to_string());
        }
    }

    // PATH search
    let path = match std::env::var("PATH") {
        Ok(x) => x,
        Err(_) => return None,
    };

    #[cfg(windows)]
    let sep = ';';
    #[cfg(not(windows))]
    let sep = ':';

    for dir in path.split(sep) {
        if dir.is_empty() {
            continue;
        }

        #[cfg(windows)]
        {
            for ext in ["", ".exe", ".bat", ".cmd"] {
                let cand = std::path::Path::new(dir).join(format!("{bin}{ext}"));
                if cand.is_file() {
                    return Some(cand.to_string_lossy().to_string());
                }
            }
        }

        #[cfg(not(windows))]
        {
            let cand = std::path::Path::new(dir).join(bin);
            if cand.is_file() {
                return Some(cand.to_string_lossy().to_string());
            }
        }
    }

    None
}

//
// ---------- CLI Definitions
//

#[derive(Parser, Debug)]
#[command(name = "mmx")]
#[command(about = "MMX â€” media swiss-army CLI")]
struct Cli {
    #[command(subcommand)]
    cmd: Command,
}

#[derive(Subcommand, Debug)]
pub enum Command {
    Remux(RemuxArgs),
    /// Run a transcode with a chosen backend
    Run(RunArgs),
    /// Probe input media
    Probe(ProbeArgs),
    /// Quality check between two files
    Qc(QcArgs),
    /// Package for streaming (HLS/DASH)
    Pack(PackArgs),
    /// Environment + dependency health check
    Doctor,
}

//
// ---------- Subcommand Args
//

#[derive(Args, Debug, Clone)]
pub struct RunArgs {
    /// Backend name (gst)
    #[arg(long = "backend")]
    backend: String,

    /// Input path
    #[arg(long = "input")]
    input: String,

    /// Output path
    #[arg(long = "output")]
    output: String,

    /// Constant frame rate
    #[arg(long, default_value_t = false)]
    cfr: bool,

    /// Output FPS (when CFR)
    #[arg(long)]
    fps: Option<u32>,

    /// Execute the graph
    #[arg(long, default_value_t = false)]
    execute: bool,

    /// Job manifest path (optional)
    #[arg(long)]
    manifest: Option<String>,

    /// Stream JSON Lines progress to stdout
    #[arg(long = "progress-json", default_value_t = false)]
    progress_json: bool,

    /// Hardware encoder (vt|nvenc|qsv|vaapi|cpu)
    #[arg(long = "hardware")]
    hardware: Option<String>,
}

#[derive(Args, Debug, Clone)]
pub struct ProbeArgs {
    /// Input media file
    #[arg(long)]
    input: String,
}

#[derive(Args, Debug, Clone)]
pub struct QcArgs {
    /// Reference file
    #[arg(long = "ref-path")]
    ref_path: String,

    /// Distorted/comparison file
    #[arg(long = "dist-path")]
    dist_path: String,

    /// Compute PSNR
    #[arg(long, default_value_t = false)]
    psnr: bool,

    /// Compute SSIM
    #[arg(long, default_value_t = false)]
    ssim: bool,

    /// Optional VMAF model path
    #[arg(long = "vmaf-model")]
    vmaf_model: Option<String>,
}

#[derive(Args, Debug, Clone)]
pub struct PackArgs {
    /// Input media file
    #[arg(long)]
    input: String,

    /// Packager kind: hls | dash
    #[arg(long, default_value = "hls")]
    packager: String,

    /// Output directory for HLS
    #[arg(long = "hls-out")]
    hls_out: Option<String>,

    /// Output directory for DASH
    #[arg(long = "dash-out")]
    dash_out: Option<String>,

    /// Segment duration (seconds)
    #[arg(long = "segment-duration", default_value_t = 4)]
    segment_duration: u32,

    /// Suggest a ladder automatically
    #[arg(long = "auto-ladder", default_value_t = true)]
    auto_ladder: bool,

    /// Explicit ladder spec (e.g. 640x360@500k,1280x720@1500k,1920x1080@3000k)
    #[arg(long = "ladder")]
    ladder: Option<String>,

    /// Enable per-shot analysis (placeholder)
    #[arg(long = "per-shot", default_value_t = false)]
    per_shot: bool,

    /// Tone-map policy: auto|off (placeholder)
    #[arg(long = "tone-map", default_value = "auto")]
    tone_map: String,
}

//
// ---------- Command Handlers
//

fn cmd_run(a: RunArgs) -> Result<()> {
    let mut opts = RunOptions::default();
    opts.backend = a.backend;
    opts.input = a.input;
    opts.output = a.output;
    opts.cfr = a.cfr;
    opts.fps = a.fps;
    opts.execute = a.execute;
    opts.manifest = a.manifest.map(std::path::PathBuf::from);
    opts.progress_json = a.progress_json;
    opts.hardware = a.hardware;
    backend::run(opts)
}

fn cmd_probe(a: ProbeArgs) -> Result<()> {
    let rep = backend::probe(&a.input)?;
    println!("{}", serde_json::to_string_pretty(&rep)?);
    Ok(())
}

fn cmd_qc(a: QcArgs) -> Result<()> {
    let q = QcOptions {
        ref_path: a.ref_path,
        dist_path: a.dist_path,
        vmaf_model: a.vmaf_model,
    };
    let rep = backend::qc(&q)?;
    println!("{}", serde_json::to_string_pretty(&rep)?);
    Ok(())
}

fn cmd_pack(a: PackArgs) -> Result<()> {
    let kind = match a.packager.as_str() {
        "hls" => PackKind::Hls,
        "dash" => PackKind::Dash,
        other => bail!("unknown --packager {}", other),
    };

    let out_dir = match kind {
        PackKind::Hls => a
            .hls_out
            .ok_or_else(|| anyhow::anyhow!("--hls-out <dir> is required for --packager hls"))?,
        PackKind::Dash => a
            .dash_out
            .ok_or_else(|| anyhow::anyhow!("--dash-out <dir> is required for --packager dash"))?,
    };

    packager::pack_unified_auto(
        kind,
        std::path::Path::new(&a.input),
        std::path::Path::new(&out_dir),
        a.segment_duration,
        a.auto_ladder,
        a.ladder.as_deref(),
        a.per_shot,
        &a.tone_map,
    )?;

    eprintln!("[pack] wrote to {}", out_dir);
    Ok(())
}

//
// ---------- Doctor + Remux
//

#[derive(clap::Args, Debug, Clone)]
pub struct RemuxArgs {
    /// Input file
    #[arg(long)]
    pub input: String,

    /// Output file
    #[arg(long)]
    pub output: String,

    /// Optional start seconds (trim-in)
    #[arg(long)]
    pub ss: Option<f64>,

    /// Optional end seconds (trim-out)
    #[arg(long)]
    pub to: Option<f64>,

    /// ffmpeg-like mapping: "0:v:0,0:a:0,0:s?"
    #[arg(long, default_value = "0:v:0,0:a?,0:s?")]
    pub stream_map: String,
}

fn cmd_remux(a: RemuxArgs) -> anyhow::Result<()> {
    use std::process::Command;

    // Find ffmpeg
    let ff = which_path("ffmpeg")
        .or_else(|| std::env::var("FFMPEG").ok())
        .ok_or_else(|| anyhow::anyhow!("ffmpeg not found in PATH (or FFMPEG env). Install ffmpeg."))?;

    let mut args: Vec<String> = vec!["-y".into(), "-hide_banner".into(), "-nostdin".into()];

    if let Some(ss) = a.ss {
        args.push("-ss".into());
        args.push(format!("{ss}"));
    }
    args.push("-i".into());
    args.push(a.input.clone());
    if let Some(to) = a.to {
        args.push("-to".into());
        args.push(format!("{to}"));
    }

    // stream map: "0:v:0,0:a?,0:s?"
    let smap = if a.stream_map.trim().is_empty() {
        "0:v:0,0:a?".to_string()
    } else {
        a.stream_map.clone()
    };
    for part in smap.split(',').map(|x| x.trim()).filter(|x| !x.is_empty()) {
        args.push("-map".into());
        args.push(part.into());
    }

    args.extend([
        "-c:v".into(),
        "copy".into(),
        "-c:a".into(),
        "copy".into(),
        "-c:s".into(),
        "copy".into(),
    ]);
    args.push(a.output.clone());

    let status = Command::new(&ff)
        .args(&args)
        .status()
        .map_err(|e| anyhow::anyhow!("failed to spawn ffmpeg: {e}"))?;
    if !status.success() {
        return Err(anyhow::anyhow!("ffmpeg remux failed (exit {status})"));
    }
    println!("[remux] wrote {}", a.output);
    Ok(())
}

fn cmd_doctor() -> anyhow::Result<()> {
    let ff = std::env::var("FFMPEG").ok().or_else(|| which_path("ffmpeg"));
    let ffp = std::env::var("FFPROBE").ok().or_else(|| which_path("ffprobe"));
    let gst = which_path("gst-launch-1.0");
    let rep = serde_json::json!({
        "mmx": "ok",
        "deps": {
            "ffmpeg": ff.unwrap_or_else(|| "<missing>".into()),
            "ffprobe": ffp.unwrap_or_else(|| "<missing>".into()),
            "gstreamer": gst.unwrap_or_else(|| "<missing>".into())
        },
        "env": {
            "PATH": std::env::var("PATH").unwrap_or_default(),
            "FFMPEG": std::env::var("FFMPEG").unwrap_or_default(),
            "FFPROBE": std::env::var("FFPROBE").unwrap_or_default()
        }
    });
    println!("{}", serde_json::to_string_pretty(&rep)?);
    Ok(())
}

//
// ---------- Main Dispatch
//

fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Run(a) => cmd_run(a)?,
        Command::Probe(a) => cmd_probe(a)?,
        Command::Qc(a) => cmd_qc(a)?,
        Command::Pack(a) => cmd_pack(a)?,
        Command::Doctor => cmd_doctor()?,
        Command::Remux(a) => cmd_remux(a)?,
    }
    Ok(())
}
