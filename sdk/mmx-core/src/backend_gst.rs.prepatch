// 0BSD â€” GStreamer backend (feature-gated, minimal-safe)
#![cfg(feature = "gst")]

use anyhow::Result;
use gstreamer as gst;

use crate::backend::{Backend, RunOptions, QcOptions};

pub struct GstBackend;

impl GstBackend {
    fn ensure_inited() -> Result<()> {
        // gst::init() is sufficient (is_idempotent enough for our use)
        gst::init()?;
        Ok(())
    }

    fn build_pipeline_string(opts: &RunOptions) -> String {
        let mut chain = vec![format!("filesrc location={} ! decodebin", crate::shell_escape::escape(&opts.input))];
        if opts.cfr || opts.fps.is_some() {
            let fps = opts.fps.unwrap_or(30);
            chain.push(format!("videorate ! video/x-raw,framerate={}/1", fps));
        }
        // placeholder encode/mux/sink path; swap in vtenc_h264_hw / vaapih264enc / nvh264enc later
        chain.push("x264enc tune=zerolatency ! mp4mux ! filesink".into());
        chain.push(format!("location={}", crate::shell_escape::escape(&opts.output)));
        chain.join(" ! ")
    }
}

impl Backend for GstBackend {
    fn name(&self) -> &'static str { "gst" }

    fn run(&self, opts: &RunOptions) -> Result<()> {
        Self::ensure_inited()?;
        let pipe = Self::build_pipeline_string(opts);
        println!("[gst] planned pipeline:\n  {}", pipe);
        Ok(())
    }

    fn probe(&self, path: &str) -> Result<crate::probe::ProbeReport> {
        // Keep it stable across gstreamer versions for now; upgrade to pbutils::Discoverer later.
        crate::probe::cheap_probe(path)
    }

    fn qc(&self, _opts: &QcOptions) -> Result<crate::qc::QcReport> {
        Ok(crate::qc::QcReport{ psnr: None, ssim: None, vmaf: None, details: "QC via gst not implemented yet".into() })
    }
}
